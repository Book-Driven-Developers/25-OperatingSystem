# 12-1 동기화란
## 동기화
동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행

**프로세스 동기화** : 프로세스들 사이의 수행 시기를 맞추는 것
- 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
- 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

### 실행 순서 제어를 위한 동기화
Writer, Reader 프로세스 동시에 실행 중일 때

Reader 프로세스는 Writer 프로세스 실행이 끝나야 비로소 실행할 수 있음

"Book.txt 안에 값이 존재한다"는 특정 조건이 만족되어야만 실행을 이어나갈 수 있음

### 상호 배제를 위한 동기화
프로세스 A : 현재 저축된 금액에 2만원을 넣는 프로세스
프로세스 B : 현재 저축된 금액에 5만원을 넣는 프로세스

![alt text](<images/img1.png>)

![alt text](<images/img2.png>)

상호 배제를 위한 동기화 : 동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 함

## 생산자와 소비자 문제
```
총합 = 10

생산자 () {
   버퍼에 데이터 삽입
   '총합' 변수 1 증가
}
소비자 () {
   버퍼에서 데이터 빼내기
   '총합' 변수 1 감소
}
```

생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않으면 문제가 발생할 수 있다

소비자가 생산자의 작업이 끝나기도 전에 총합을 수정하고, 생상자가 소비자의 작업이 끝나기도 전에 총합을 수정함 

=> 동시에 접근해서 발생하는 문제

## 공유 자원과 임계 구역
**공유 자원** : 동시에 실행되는 프로세스들이 접근하는 공동의 자원

**임계 구역** : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기

임계 구역에 먼저 진입한 프로세스의 작업이 마무리되면 그제서야 비로소 기다렸던 프로세스가 임계 구역에 진입

![alt text](<images/img3.png>)

**레이스 컨디션** : 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우

![alt text](<images/img4.png>) 

![alt text](<images/img5.png>)

**동기화를 위한 세 가지 원칙**
- 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
- 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
- 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다

# 12-2 동기화 기법
## 뮤텍스 락
임계 구역에 진입하는 프로세스는 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입 가능

- 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제하는 역할 : release 함수

```
acquire() {
    while (lock == true) /* 만약 임계 구역이 잠겨 있다면 */
        ;                /* 임계 구역이 잠겨 있는지를 반복적으로 확인 : 바쁜 대기 */
    lock = true;         /* 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
}

release() {
    lock = false;        /* 임계 구역 작업이 끝났으니 잠금 해제 */ 
}
```

acquire와 release 함수를 아래와 같이 임계 구역 전후로 호출함으로써 하나의 프로세스만 임계 구역에 진입 가능
```
acquire();
// 임계 구역
release();
```

프로세스는
- 락을 획득할 수 없다면 무작정 기다리고
- 락을 획득할 수 있다면 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고
- 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제

## 세마포어
공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구

구성 요소
- 임계 구역에 진입할 수 있는 프로세스의 개수를 나타내는 **전역 변수 S**
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 **wait 함수**
- 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 **signal 함수**

```
wait() {
    whlie ( S <= 0)
    ;
    S--;
}
```
1. 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
2. 사용할 수 있는 자원이 있는지 반복적으로 확인하고,
3. 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역에 진입한다.

```
signal() {
    S++
}
```
임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.


```
wait()
// 임계 구역
signal()
```

![alt text](<images/img6.png>)

### 발전된 방법

```
wait() {
    S--;
    if ( S < 0 ) {
        add this process to Queue;
        sleep()
    }
}
```
해당 프로세스의 PCB를 대기 큐에 삽입하여 처리

```
signal() {
    S++
    if (S <= 0) {
        remove a process p from Queue
        wakeup(p)
    }
}
```
1. 대기 큐에 있는 프로세스 p를 제거한다.
2. 프로세스 p를 대기 상태에서 준비 상태로 만든다.

![alt text](<images/img7.png>)

## 모니터
wait와 signal 함수를 명시하는 것은 번거로운 일, 잘못 사용될 수 잇음

모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리하므로 편리함

모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공함

![alt text](<images/img8.png>)

**조건 변수** : 프로세스나 스레드의 실행 순서를 제어하기 위해 사용

![alt text](<images/img9.png>)

모니터에 진입한 어떤 프로세스가 x.wait() 실행 -> 조건 변수 x에 대한 큐에 삽입

x.signal()을 호출하면 조견 변수 x에 대해 대기 상태에 있던 프로세스가 깨어나 모니터 안으로 다시 들어옴

# Spring에서 동기화 기법 활용 방안
## 뮤텍스
- 같은 자원에 대한 재고 차감 / 쿠폰 발급 / 포인트 적립 등과 같은 **상태 변경**이 일어났을 때 
- 같은 사용자/주문에 대해 한 번만 처리하여 **중복 요청 방지**
- 특정 작업을 한 번에 하나만 돌리고 싶을 때
- 스프링에서 ReentrantLock, synchronized 를 활용할 수 있음
```
Lock lock = new ReentrantLock();

try {
    lock.lock(); // 락 획득
    // 임계 영역
} finally {
    lock.unlock(); // 락 해제
}
```
## 세마포어
- 외부 결제/문자/메일 API 호출을 동시 5건으로 제한
- 이미지 처리/AI 추론 같은 고비용 작업 동시 실행 제한
- DB 커넥션/스레드풀이 버티는 범위 내로 폭주 방지
- 특정 엔드포인트(예: /export)가 몰리면 서버가 죽는 걸 막기
- java.util.concurrent.Semaphore 활용 가능
```
import java.util.concurrent.Semaphore;

@Service
public class ExternalApiService {

    // 동시에 최대 3개 요청만 허용
    private final Semaphore semaphore = new Semaphore(3);

    public void callExternalApi(int requestId) {
        try {
            semaphore.acquire(); // permit 획득 (없으면 대기)
            System.out.println("요청 " + requestId + " 실행 시작");

            // 외부 API 호출 시뮬레이션
            Thread.sleep(2000);

            System.out.println("요청 " + requestId + " 실행 종료");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            semaphore.release(); // permit 반납
        }
    }
}
```
## 모니터
- 객체 단위로 임계 영역을 간단하게 보호해야 하는 경우
- 조건에 따라 대기/알림이 필요한 경우
- 복잡한 락 관리가 필요 없는 단일 JVM 환경에서 적합
- synchronized 키워드를 통해 Java Monitor를 활용 가능

# 스터디 피드백

## lock을 걸지 못했을 때 vs wait()가 실행되었을 때

### 1. lock을 걸지 못했을 때 (락 대기)
- 상황
  - 다른 스레드가 이미 락을 보유 중
  - `synchronized` 진입 실패 또는 `lock()` 대기
- 락 상태
  - ❌ 락을 얻지 못함
- 스레드 상태
  - BLOCKED (synchronized 기준)
- 대기 위치
  - Entry List (락 대기 큐)
- 특징
  - 락이 풀리면 자동으로 경쟁에 참여
  - 조건과 무관하게 “락만 풀리면” 진입 시도

### 2. wait()가 실행되었을 때 (조건 대기)
- 상황
  - 락을 **이미 획득한 상태**에서
  - 조건이 만족되지 않아 스스로 대기
- 락 상태
  - ⭕ wait() 호출과 동시에 락을 반납
- 스레드 상태
  - WAITING
- 대기 위치
  - Wait Set (조건 대기 큐)
- 특징
  - `notify()/notifyAll()`을 받아야 깨어남
  - 깨어난 뒤에도 **다시 락 획득 경쟁 필요**
  - 조건 충족 여부를 재확인해야 함 (while)

## synchronized / ReentrantLock과의 관계

- 위 차이는 `synchronized`와 `ReentrantLock`의 설계 방식 차이에서 비롯된다.

- `synchronized`
  - 락 대기와 조건 대기가 **JVM 모니터 구조에 고정**되어 있음
  - 락을 얻지 못한 스레드는 Entry List에서 대기
  - `wait()`를 호출한 스레드는 Wait Set에서 조건 대기
  - 조건 대기 큐를 **분리해서 관리할 수 없음**

- `ReentrantLock`
  - 락 대기와 조건 대기를 **명시적으로 분리**해서 제공
  - 락 대기는 Lock 내부 큐에서 관리
  - 조건 대기는 `Condition` 객체별 대기 큐에서 관리 가능
  - 여러 조건에 대해 **독립적인 대기/신호 처리**가 가능

- 정리
  - `synchronized`는 구조가 단순하지만 제어력이 낮고
  - `ReentrantLock`은 설계가 복잡한 대신 동기화 제어가 세밀하다