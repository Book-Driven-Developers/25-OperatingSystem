## 12-1 동기화란

운영체제의 프로세스 관리 서비스 중 가장 중요한 두 가지를 꼽자면 스케줄링과 동기화입니다. 지난 장에서 스케줄링을 학습했다면 이번에는 동기화에 대해 알아봅시다.

동시다발적으로 실행되는 프로세스들은 공동의 목적을 올바르게 수행하기 위해 서로 협력하며 영향을 주고 받기도 합니다. 이렇게 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 **동기화(synchronization)**되어야 합니다.

이번 절에서 동기화란 무엇인지 개념을 정리하고, 프로세스를 동기화하지 않을 경우 발생 할 수 있는 문제들을 통해 동기화가 왜 필요한지 알아봅니다.

### 동기화의 의미

동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행될 수 있습니다. 예를 들어 워드 프로세서에는 사용자로부터 입력을 받는 프로세스와 입력한 내용의 맞춤법을 검사하는 프로세스, 입력한 내용을 화면에 출력해 주는 프로세스 등이 있습니다. 이 프로세스들은 각기 다른 독립적인 프로세스이지만 공동의 목표를 위해 서로 협력하는 존재입니다.

이렇게 협력적으로 실행되는 프로세스들은 아무렇게나 마구 동시에 실행해서는 안됩니다. 올바른 실행을 위해서는 **동기화**가 필수입니다.

**프로세스 동기화**란 프로세스들 사이의 수행 시기를 맞추는 것을 의미합니다.

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기

> 프로세스뿐만 아니라 스레드도 동기화 대상입니다. 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상입니다. 다만 이 책에서는 대부분의 전공서 표현에 따라 ‘프로세스 동기화’라고 칭하겠습니다.
>

**동기화**는 특정 자원에 접근할 때 한 개의 프로세스만 접근하게 하거나, 프로세스를 올바른 순서대로 실행하게 하는 것을 의미합니다.

즉, 동기화에는 1. 실행 순서 제어를 위한 동기화가 있고, 2. 상호 배제를 위한 동기화가 있습니다.

**첫째, 실행 순서 제어를 위한 동기화에 대해 알아봅시다.**

가령 Writer라는 프로세스와  Reader라는 프로세스가 동시에 실행 중이라고 가정해 보겠습니다.

Writer 프로세스는 Book.txt 파일에 값을 저장하는 프로세스이고, Reader 프로세스는 Book.txt 파일에 저장된 값을 읽어 들이는 프로세스라고 가정해 보죠.

이 두 프로세스는 아무 순서대로 실행되어서는 안됩니다. Writer 프로세스가 Book.txt에 값을 저장하기도 전에 Reader 프로세스가 Book.txt를 읽는 것은 올바른 실행 순서가 아닙니다. 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 첫 번째 프로세스 동기화입니다.

**둘째, 상호 배제를 위한 동기화**

**상호 배제(mutual exclusion)**는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘입니다. 이 또한 간단한 예시를 들어 보겠습니다. 가령 계좌에 10만원이 저축되어 있다고 가정해 봅시다.

프로세스A 의 실행 과정은

1. 계좌의 잔액을 읽어 들인다.
2. 읽어 들인 잔액에 2만 원을 더한다.
3. 더한 값을 저장한다.

마찬가지로 프로세스 B가 실행되는 과정은

1. 계좌의 잔액을 읽어 들인다.
2. 읽어 들인 잔액에 5만원을 더한다.
3. 더한 값을 저장한다.

이제 프로세스 A와 B가 동시에 실행됐다고 가정해 봅시다. 실행 결과 16만 원이 계좌에 남을 것을 기대할 것이지만 동기화가 전혀 이루어지지 않은 경우 엉뚱한 결과가 나올 수 있다.

- 동기화가 이루어지지 않은 경우

프로세스 A와 B가 동시에 실행되면 다음과 같은 상황이 발생할 수 있습니다.

| **시간** | **프로세스 A** | **프로세스 B** | **계좌 잔액** |
| --- | --- | --- | --- |
| t1 | 잔액 읽기 (10만원) |  | 10만원 |
| t2 |  | 잔액 읽기 (10만원) | 10만원 |
| t3 | 10만원 + 2만원 = 12만원 |  | 10만원 |
| t4 |  | 10만원 + 5만원 = 15만원 | 10만원 |
| t5 | 12만원 저장 |  | 12만원 |
| t6 |  | 15만원 저장 | 15만원 |

위 표에서 볼 수 있듯이 프로세스 A가 계산한 12만원은 프로세스 B의 15만원에 덮어씌워지면서 사라집니다. 결과적으로 계좌에는 기대했던 17만원이 아닌 15만원만 남게 되는 문제가 발생합니다.



왜 이런 일이 발생했을까요? A와 B는 ‘잔액’이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버렸기 때문입니다. A와 B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 합니다.

- 동기화가 이루어진 경우

프로세스 A와 B가 동기화되어 실행되면 다음과 같이 올바른 결과를 얻을 수 있습니다.

| **시간** | **프로세스 A** | **프로세스 B** | **계좌 잔액** |
| --- | --- | --- | --- |
| t1 | 잔액 읽기 (10만원) | 대기 | 10만원 |
| t2 | 10만원 + 2만원 = 12만원 | 대기 | 10만원 |
| t3 | 12만원 저장 | 대기 | 12만원 |
| t4 | 완료 | 잔액 읽기 (12만원) | 12만원 |
| t5 |  | 12만원 + 5만원 = 17만원 | 12만원 |
| t6 |  | 17만원 저장 | 17만원 |

이렇게 동시에 접근해서는 안되는 자원에 동시에 접근하지 못하게 하는 것이 **상호 배제를 위한 동기화**입니다.

### 생산자와 소비자 문제

상호 배제를 위한 동기화에 고전적이고 유명한 문제로 생산자와 소비자 문제가 있습니다.

생산자와 소비자는 동시에 실행되는 스레드가 될 수도 있습니다.

생산자와 소비자는 ‘총합’이라는 데이터를 공유하고 있습니다. 생산자는 버퍼에 물건을 넣은 후, 물건의 총합에 해당하는 변수를 1 증가시키고, 소비자는 버퍼에 물건을 빼낸 후 물건의 총합에 해당하는 변수를 1 감소시킵니다.

생산자

```c
생산자 () {
				버퍼에 데이터 삽입
				'총합' 변수 1 증가
}
```

소비자

```c
소비자 () {
				버퍼에서 데이터 빼내기
				'총합' 변수 1 감소
}
```

*버퍼: 생산자가 만든 데이터를 임시 저장해 두는 공유 공간

총합 = 10으로 선언해 두고, 생산자를 100000번, 소비자를 100000번 동시에 실행해 보기로 합니다.

생산자는 그저 버퍼에 데이터를 넣고 총합을 1 증가시킬 뿐이고, 소비자는 버퍼에서 데이터를 빼고 총합을 1감소시킬 뿐이니 총합 변수가 10개로 머물로 있을 것으로 기대할 것입니다.

하지만 막상 생산자와 소비자를 동시에 실행해 보면 예상치 못한 결과를 받을 수 있습니다. 총합이 10이 아닌 다른 수가 되거나 오류가 나기도 합니다.

producer_consumer.cpp

```c
#include <iostream>
#include <queue>
#include <thread>

void produce();
void consume();

int sum = 0;

int main() {
		
		std::cout << "초기 합계: " << sum << std::endl;
		std::thread producer(produce);
		std::thread consumer(consume);
		
		producer.join();
		consumer.join();
		
		std::cout << "producer, consumer 스레드 실행 이후 합계: " << sum << std::endl;
		
		return 0;
}

void produce() {
		for(int i = 0; i < 100000; i++) {
				sum++;
		}
}

void consume() {
		for(int i = 0; i < 100000; i++) {
				sum--;
		}
}
```

![image.png](attachment:f04374d4-5c36-4bf9-b695-490c63b68ef4:image.png)

이는 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않았기 때문에 발생한 문제입니다.

앞서의 예제는 소비자가 생산자의 작업이 끝나기도 전에 총합을 수정했고, 생산자가 소비자의 작업이 끝나기도 전에 총합을 수정했기 때문에 엉뚱한 결과가 발생한 것입니다. 동시에 접근해서는 안되는 자원에 동시에 접근했기 때문에 발생한 문제라고 보 수 있습니다.

### 공유 자원과 임계 구역

동시에 접근해서는 안 되는 자원이란 무엇일까요?

계좌 잔액 문제와 생산자 소비자 문제의 예시에서 동시에 실행되는 프로세스들은 전역 변수 ‘잔액’, ‘총합’이라는 공동의 자원을 두고 작업을 했습니다. 이러한 자원을 **공유 자원**(shared resource)라고 합니다. 공유 자원은 전역 변수가 될 수도 있고, 파일이 될 수도 있고, 입출력장치, 보조기억장치가 될 수도 있습니다.

동시에 실행하면 문제가 발생하는 자원에 접근하려는 코드 영역을 **임계 구역**(critical section)이라고 합니다.

*여기서 의미하는 코드 영역: 임계 구역을 구성하는 실제 실행 코드 부분

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 합니다. 임계 구역에 먼저 진입한 프로세스의 작업이 마무리되면 그제서야 비로소 기다렸던 프로세스가 임계 구역에 진입합니다.

임계 구역(critical section)은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역이지만, 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우가 있습니다. 이를 레이스 컨디션(race condition)이라고 합니다.

계좌 잔액 문제와 생산자와 소비자 문제는 레이스 컨디션(race condition)의 사례로 볼 수 있습니다.

레이스 컨디션이 발생하는 근본적인 원인을 따져봅시다.

컴퓨터 내부에서 대략 고급 언어 한 줄은 여러 줄의 저급 언어로 변환되어 실행됩니다.

예시)

```c
총합++; // 총합 변수를 1 증가시키는 코드 (critical section)
```

→

```c
r1 = 총합; // 총합 변수를 레지스터에 저장
r1 = r1 + 1; // 레지스터 값 1 증가
총합 = r1 // 레지스터 값을 총합 변수에 저장
```

컴퓨터는 고급 언어가 아닌 저급 언어를 실행하기 때문에 여러 줄의 저급 언어로 변환된 고급 언어 한 줄을 실행하는 과정에서 문맥 교환이 일어날 수 있습니다. 저급 언어를 실행하는 과정에서 문맥 교환이 일어난다면 아래와 같은 문제가 발생합니다.

| **시간** | **프로세스 A** | **프로세스 B** | 현재 총합 | 현재 r1 | 현재 r2 |
| --- | --- | --- | --- | --- | --- |
| t1 | r1 = 총합 |  | 10 | 10 |  |
| t2 | r1 = r1 + 1 |  | 10 | 11 |  |
| t3 | 문맥 교환 |  | 10 | 11 |  |
| t4 |  | r2 = 총합 | 10 | 11 | 10 |
| t5 |  | r2 = r2 - 1 | 10 | 11 | 9 |
| t6 |  | 문맥 교환 | 10 | 11 | 9 |
| t7 | 총합 = r1 |  | 11 | 11 | 9 |
| t8 | 문맥 교환 |  | 11 | 11 | 9 |
| t9 |  | 총합 = r2 | **9** | 11 | 9 |

운영체제는 이러한 임계 구역 문제를 아래 세 가지 원칙 하에 해결합니다. 달리 말해 상호배제를 위한 동기화를 위해서는 아래 세 가지 원칙이 반드시 지켜져야 합니다.

- 상호 배제(mutual exclusion): 한 프로세스가 임계 구역(critical section)에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
- 진행(progress): 임계 구역(critical section)에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- 유한 대기(bounded waiting): 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다(무한정 대기해서는 안된다)