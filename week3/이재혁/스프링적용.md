## 스프링 개발에서 언제 적용되나?
스프링은 기본적으로 멀티 스레드 환경이라, "공유 상태"가 있으면 동기화가 필요합니다.
다만 분산 환경(서버가 여러 대) 이면 동기화를 위해 JVM 락만으로는 부족합니다.

### Mutext Lock이 실제로 필요한 순간
"한 JVM 안에서 공유되는 메모리 상태"를 보호할 때
- 싱글톤 빈이 내부에서 클래스 상태(변수)를 갖는 경우(권장X 지만 종종 발생)
  - 예: `Map` 캐시 직접 관리, 배치 집계 중간 상태 등
  - 해결: 상태 값을 없애거나(불변/지역 변수화), 필요시 mutex lock 사용
- 단일 프로세스에서만 정확하면 되는 임계 구역(critical section)
  - 같은 인스턴스 내 "중복 실행 방지" 나 "한 번만 초기화" 같은 로직

*스프링에서 흔한 선택지
- 단일 인스턴스면: synchronized / ReentrantLock / MutexLock 구현
- 멀티 인스턴스면: DB락, Redis 분산락, 유니크 조건, 메시지 큐 등으로 해결


## Semaphore가 실제 필요한 순간
- 외부 API 호출 동시 요청 제한(Rate Limit, Circuit Breaker와 자주 사용)
- 특정 리소스 동시 사용량 제한
- 대용량 작업에서 "동시 실행 수"를 제한해서 서버 안정화

*스프링에서 흔한 적용 위치
- `@Async` 작업 수 제한
- `@Scheduled` 작업이 겹치지 않게 하되, "일부만 허용" 같은 요구(예: 최대 2개 워커만)

## Monitor(모니터)가 필요한 순간
모니터는 락 + 조건대기까지 묶인 형태라서, 아래 같은 패턴에서 등장합니다.
- 생산자/소비자, 큐 기반 파이프라인(조건에 따라 대기/깨우기)
- 특정 상태가 만족될 때까지 기다렸다가 진행해야 하는 흐름

*스프링 실무에서는
- BlockingQueue(LinkedBlockingQueue, ArrayBlockingQueue)
- CountDownLatch, CyclicBarrier, CompletableFuture 같은 고수준 동시성 도구로 대체

