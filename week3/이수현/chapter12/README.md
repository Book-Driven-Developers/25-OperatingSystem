# chapter12 - 프로세스 동기화
## 12-1 동기화란 
> 동시다발적으로 실행되는 프로세스, 스레드들은 서로 협력하며 영향을 주고 받음
> 
> 이 과정에서 자원의 일관성 (= 동기화)을 보장해야한다.
> > 앞으로 정리한 내용들에서 나오는 동기화 대상을 편의상 프로세스와 스레드를 합쳐서 프로세스라고 하겠다.
### 동기화의 의미
+ 프로세스(또는 스레드)들의 수행 시기를 맞추는 것
+ 어떻게?
  + **실행 순서 제어**: 프로세스를 올바른 순서대로 실행
  + **상호 배제**: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기 
### 1. 실행 순서 제어를 위한 동기화
#### 필요한 이유 1: Reader Writer Problem
<img width="310" height="215" alt="Image" src="https://github.com/user-attachments/assets/1dd62e26-14ab-44f8-95ea-d30458bbb3b7" />

+ 상황
  + Writer: Book.txt 파일에 값을 저장하는 프로세스
  + Reader: Book.txt 파일에 저장된 값을 읽어들이는 프로세스
+ Reader, Writer 프로세스는 무작정 아무렇게나 실행되어선 안됨 -> 실행 순서가 있기 때문!
+ Reader 프로세스는 'Book.txt 안에 값이 존재한다'틑 특정 조건이 만족되어야만 실행 가능
### 2. 상호 배제를 위한 동기화
공유가 불가능한 자원의 동시 사용을 피하기 위한 동기화

**한 번에 하나의 프로세스**만 접근해야 하는 자원에 동시 접근을 피하기 위한 동기화
#### 필요한 이유 2: Back Account Problem
<img width="478" height="257" alt="Image" src="https://github.com/user-attachments/assets/1a62cc37-9088-46bc-917a-bd6f068ed5b0" />

+ 상황
  + 현재 계좌의 잔액: 10만원
  + 프로세스A: 현재 잔액에 2만원을 추가하는 프로세스
  + 프로세스B: 현재 잔액에 5만을 추가하는 프로세스
+ 만약 동기화 없이 무작위로 프로세스들이 실행된다면?
  + -> 실행 결과: 둘다 잔액을 10만원으로 읽게 되어 최종적으로 잔액이 15만원이 될 수 있다.
  + -> why? 프로세스A의 자원에 대한 실행이 다 끝나기 전에 프로세스B가 해당 자원에 접근해서
#### 필요한 이유: Producer & Consumer Problem
<img width="554" height="238" alt="Image" src="https://github.com/user-attachments/assets/79cce9af-7969-4568-a3cc-84b529d05279" />

+ 상황
  + Producer: 물건을 계속해서 생산하는 프로세스
  + Consumer: 물건을 계속해서 소비하는 프로세스
  + '총합' 변수를 공유하고 있음
+ 만약 생산자를 100,000번, 소비자를 100,000번 실행하면 총합은?
  + -> 떄로는 0과 다른 값이 되거나 오류가 발생하기도 함
  <img width="561" height="157" alt="Image" src="https://github.com/user-attachments/assets/00ec897c-c85f-425b-a424-e94618e16a38" />

#### 상호 배제를 위한 동기화를 위한 세가지 원칙
1. 상호 배제 (mutual exclusion)
   + 한 프로세스가 임계구역에 진입했다면, 다른 프로세스는 들어올 수 없다.
2. 진행 (progress)
   + 임계 구역에 어떤 프로세스도 진입하지 않았다면, 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3. 유한 대기 (bounded waiting)
   + 한 프로세스가 임계 구역에 진입하고 싶다면, 언제가는 임계 구역에 들어올 수 있어야 한다.
   + 즉, 임계 구역에 들어오기 위해 ~~무한대기~~를 해서는 안된다.

### 공유 자원과 임계 구역
> 동시에 접근해서는 안되는 자원을 가리킴
#### 공유 자원
+ 여러 프로세스 혹은 스레드가 **공유하는 자원**
+ ex) 전역 변수, 파일, 입출력장치, 보조기억장치, ...
#### 임계 구역
<img width="500" height="192" alt="Image" src="https://github.com/user-attachments/assets/c7deb851-7066-417e-82d3-4496e6c7d10b" />

+ 동시에 실행하면 문제가 발생하는 자원에 접근하는 **코드 영역**
+ ex) 총합 변수에 접근하는 코드, 잔액 변수에 접근하는 코드
+ 임계구역에 진입하고자 하면, 진입한 프로세스 이외에는 대기해야함.

#### Race Condition
+ 임계 구역에 동시에 접근하여 자원의 일관성이 깨지게되는 현상
+ Back Account Problem, Producer & Consumer Problem 모두 레이스 컨디션 사례에 해당함
<p>
<img width="464" height="304" alt="Image" src="https://github.com/user-attachments/assets/24cf4feb-1fb8-4611-bef6-18fc307e2e9a" />
<em><br>
고급언어로 작성된 한 줄짜리 코드라도, 저급언어로는 여러 줄로 변환될 수 있다. <br>
이때 문맥교환이 발생하면, 자원의 일관성이 깨질 수 있음
</em>
</p>

---
## 12-2 동기화 기법
> 여러 기법 중 교재에서는 대표적인 3가지만 소개함
### 1. 뮤텍스 락
+ 상호 배제를 위한 동기화 도구(자물쇠 역할)
#### 간단한 구현 방법 (상호 배제를 위한 동기화)
+ 준비 사항
  + lock: 프로세스들이 공유하는 전역변수 -> 자물쇠 역할
  + acquire(): 임계 구역을 잠그는 역할
  + release(): 임계 구역의 잠금을 해제하는 역할
+ 의사코드(Pseudo-code)
  + acquire, release 예시
    ```cpp
    acquire(){
      while(lock == true){ // 임계 구역이 잠겨 있다면,
          ;                // 임계구역이 잠겨 있는지 반복적으로 확인 (바쁜 대기)
      }
      lock = true;         // 임계구역이 잠겨 있지 않다면, 잠금
    }
    release(){
      lock = false;        // 임계 구역 작업이 끝났으니 잠금해제
    }
    ```
  + 적용 예시
    ```cpp
    acquire();   // 자물쇠가 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 임계구역 진입
    //{임계 구역}  // 임계 구역에서의 작업 진행
    release();   // 작업이 끝나면, 자물쇠 반환
    ```

### 2. 세마포
+ 좀 더 일반화된 방식의 동기화 도구
+ 공유 자원이 여러 개 있는 경우에도 적용 가능
+ 종류
  + 이진 세마포: 뮤텍스 락과 비슷
  + 카운팅 세마포: 여러개의 자원에 대해 적용 가능
#### 간단한 구현 방법 (상호 배제를 위한 동기화)
+ 준비사항
  + S: 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 **전역 변수**
  + wait(): 임계구역에 들어가도 좋은지, **기다려야 할지 알려주는** 함수
  + signal(): 임계구역 앞에서 기다리는 프로세스에 **'진입 가능' 신호**를 주는 함수
+ 의사코드(Pseudo-code)
  + wait(), signal() 예시
    ```cpp
    wait(){
        while( S<=0 ) // 만약 사용할 수 있는 자원이 없다면,
        ;             // 사용할 수 있는 자원이 있는지 반복적으로 확인 (바쁜 대기)
        S--;          // 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면, 자원 하나를 사용하고 임계 구역 진입
    }
    signal(){
        S++;          //임계구역에서의 작업을 마친 뒤 자원하나를 해제한다.
    }
    ```
  + 적용 예시
    ```cpp
    wait()
    // {임계구역}
    signal()
    ```
#### 바쁜 대기 (Busy Waiting)
+ 계속해서 락이 걸려있는지 수시로 확인하는 것
+ 문제: CPU 사이클을 낭비하게 됨!
+ 해결 방법
  + 사용할 수 있는 자원이 없을 경우, 대기 상태로 만듦 
  > 해당 프로세스의 PCB를 대기큐에 삽입
  + 사용할 수 있는 자원이 생겼을 경우, 대기 큐의 프로세스를 준비상태로 만듦 
  > 해당 프로세스의 PCB를 대기큐에서 꺼내 준비 큐에 삽입
+ 해결 방법 구현 예시
  ```cpp
  wait(){
    S--;
    if ( S<0 ){
      add this process to Queue;  //자원이 없으므로, 해당 프로세스 PCB를 대기큐에 삽입
      sleep();                    //해당 프로세스는 대기 상태로 접어든다.
    }
  }
  signal(){
    S++;
    if ( S <=0 ){
      remove a process p from Queue;  // 자원이 생기면, 대기큐로부터 프로세스 p를 제거함
      wakeup(p);                      // 프로세스 p를 대기상태에서 준비상태로 만듦.
    }
  }
  ```
#### 간단한 구현 방법 (실행 순서 동기화)
<img width="388" height="166" alt="Image" src="https://github.com/user-attachments/assets/5cbe2ec1-e2e5-4346-9854-5951318afefa" />

+ 세마포의 변수 S를 0으로 두고,
+ 먼저 실행할 프로세스 뒤에 signal 함수를, 
+ 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 됨.

### 3. 모니터
> 등장 배경
> 
> 세마포를 사용하게되면 매번 임계구역 앞 뒤로 wait(), signal()을 호출해야함
> 
> -> 실수 발생 가능 + 디버깅이 어려움!
+ 사용자가 다루기에 편한 동기화 도구
+ 모니터를 활용하는 가장 대표적인 언어 -> **JAVA**
+ 상호배제, 실행 순서를 위한 동기화 둘 다 지원해줌
#### 간단한 구현 방법 (상호 배제를 위한 동기화)
<img width="540" height="215" alt="Image" src="https://github.com/user-attachments/assets/db9c5cce-ef39-4b29-a39a-3bb22114bc5d" />

+ 준비 사항
  + 큐: 인터페이스를 위해 필요
+ 동작 원리
  + 공유자원에 접근하고자 하는 프로세스를 큐에 삽입
  + 큐에 삽입된 순서대로 공유 자원 이용
  > 한 번에 하나의 프로세스만 공유자원 사용
  >
  > 즉, 모니터 안에는 하나의 프로세스만이 있을 수 있다!

#### 간단한 구현 방법 (실행 순서 동기화)
<img width="429" height="261" alt="Image" src="https://github.com/user-attachments/assets/63f44be5-f8e3-4f3d-9faf-dbd12bb9fa53" />

+ 준비 사항
  + 조건 변수: 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
  + 조건 변수.wait(): **대기 상태로 변경**, 조건 변수에 대한 큐에 삽입
  + 조건 변수.signal(): wait()로 인해 대기 상태로 접어든 조건 변수를 **실행 상태로 변경**
+ 동작 원리
  + 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단함
  + 특정 프로세스가 실행될 조건이 충족되었을 때는 signal을 통해 실행을 재개함 (2가지 방법 존재)
    + wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재개
    + signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤, 다시 signal()을 호출한 프로세스의 수행 재개