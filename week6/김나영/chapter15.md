# 15-1 파일과 디렉터리
## 파일
파일 : 하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합

메타데이터 : 파일을 이루는 부가 정보

### 파일 속성과 유형
![alt text](images/img1.png)
![alt text](images/img2.png)

### 파일 연산을 위한 시스템 호출
파일을 다루는 모든 작업은 운영체제에 의해 이뤄짐, 파일 연산을 위한 시스템 호출 제공

## 디렉터리
1단계 디렉터리 : 옛날 운영체제에는 모든 파일이 하나의 디렉터리 안에 존재

트리 구조 디렉터리 : 최상위 디렉터리 아래에 여러 서브 디렉터리 존재

최상위 디렉터리 : 루트 디렉터리 , "/"

### 절대 경로와 상대 경로
절대 경로 : 루트 디렉터리에서 자기 자신까지 이르는 고유한 경로

상대 경로 : 현재 디렉터리부터 시작하는 경로

### 디렉터리 엔트리
디렉터리는 보조기억장치에 테이블 형태의 정보로 저장됨

디렉터리 엔트리를 통해 보조기억장치에 저장된 위취를 찾고 이동 가능

# 15-2 파일 시스템
## 파티셔닝과 포매팅
보조기억장치에 곧바로 파일을 생성하거나 저장할 수 없음, 파티셔닝과 포매팅을 거쳐야 함

**파티셔닝** : 저장 장치의 논리적인 영역을 구획하는 작업

**포매팅** : 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업

## 파일 할당 방법
운영체제는 파일과 디렉터리를 **블록** 단위로 읽고 씀

파일 할당 방법에는 연속 할당, 불연속 할당 (연결 할당, 색인 할당) 방법 존재

### 연속 할당
보조기억장치 내 연속적인 블록에 파일을 할당하는 방식

디렉터리 엔트리에 파일 이름, 첫 번째 블록 주소, 블록 단위의 길이 명시

![alt text](images/img3.png)

단점 : **외부 단편화** 야기
![alt text](images/img4.png)

### 연결 할당
연속 할당의 문제 해결

각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당

![alt text](images/img5.png)

문제점
1. 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 함
- 임의 접근 속도가 매우 느림
2. 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록 접근 불가

### 색인 할당
파일의 모든 블록 주소를 **색인 블록**이라는 하나의 블록에 모아 관리하는 방식
![alt text](images/img6.png)

파일 내 임의의 위치 접근 편리 : 파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 됨

디렉터리 엔트리에 파일 이름, **색인 블록 주소** 명시

유닉스 파일 시스템 : 색인 할당을 기반으로 만든 파일 시스템

![alt text](images/img7.png)

## 파일 시스템 살펴보기
### FAT 파일 시스템
USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용

연결 할당의 단점을 보완

#### 파일 할당 테이블 (FAT : File Allocation Table)
각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리

하드 디스크의 한 파티션을 FAT 파일 시스템으로 포맷했을때의 구성

![alt text](images/img8.png)

FAT가 메모리에 적재된 채 실행되면 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨라지고, 임의 접근에도 유리함

**디렉터리 구성**

![alt text](images/img9.png)

![alt text](images/img10.png)

/home/minchul/a.sh에 접근하는 방법
1. 루트 디렉터리에서 home 디렉터리 블록 찾기
2. 3번 블록을 읽어 home 디렉터리 읽기, minchul 디렉터리 블록 찾기
3. 15번 블록을 읽어 minchul 디렉터리 읽기, a.sh 파일의 첫 번째 블록 주소 찾기
4. FAT 확인, 9->8->11->13 접근

### 유닉스 파일 시스템
색인 블록 : i-node
- 파일 속성 정보와 열다섯 개의 블록 주소 저장
- 파일마다 i-node 존재, i-node마다 번호가 부여되어 있음

![alt text](images/img11.png)

문제점 : i-node 크기는 유한함, i-node 하나는 열다섯 개의 블록을 차지하는 파일까지 가리킬 수 있음

해결 방법
1. 블록 주소 중 열두 개에는 직접 블록 주소 저장
- **직접 블록** : 파일 데이터가 저장된 블록
2. 열세 번째 주소에 단일 간접 블록 주소 저장
- **단일 간접 블록** : 파일 데이터를 저장한 블록 주소가 저장된 블록

![alt text](images/img12.png)

3. 열네 번째 주소에 이중 간접 블록 주소 저장
- **이중 간접 블록** : 단일 간접 블록들의 주소를 저장하는 블록
4. 열다섯 번째 주소에 삼중 간접 블록 주소 저장
- **삼중 간접 블록** : 이중 간접 블록 주소가 저장된 블록
![alt text](images/img13.png)

대표적으로 윈도우 운영체제에서는 **NT 파일 시스템**, 리눅스 운영체제에서는 **ext 파일 시스템** 사용

# ext 파일 시스템 발전 과정

ext 파일 시스템은 리눅스 환경에서 오랫동안 사용되며 점진적으로 개선되어 온 파일 시스템 계열이다.  
각 버전은 **이전 구조를 최대한 유지하면서**, 안정성, 성능, 확장성을 중심으로 발전해왔다.

---

## 1. ext2 (Second Extended File System)

### 등장 배경
- 초기 리눅스 파일 시스템(minix FS)의 한계를 극복하기 위해 등장
- 단순하고 성능이 좋은 범용 파일 시스템이 목표

### 주요 특징
- **inode 기반 구조**
- Block Group 구조 도입
- 파일 크기, 권한, 소유자, 데이터 블록 위치를 inode에 저장
- 디렉터리는 *파일명 → inode 번호* 매핑 테이블로 관리

### 한계
- **저널링(Journaling) 미지원**
- 시스템 장애 발생 시 `fsck` 전체 검사 필요
- 대용량 디스크 환경에서 복구 시간이 매우 김

### ext2가 아직 쓰이는 경우
- USB, SD 카드, 임베디드 시스템
- 저널링으로 인한 쓰기 오버헤드가 부담되는 환경

---

## 2. ext3 (Third Extended File System)

### 등장 배경
- 서버 환경에서 **안정성 요구 증가**
- ext2 구조를 유지하면서 장애 복구 문제 해결 필요

### 핵심 변화: 저널링 도입
- 파일 시스템 변경 사항을 **먼저 저널에 기록**
- 이후 실제 데이터 영역에 반영
- 장애 발생 시 저널만 확인하여 빠르게 복구 가능

### 저널링 동작 원리
1.	파일 생성/수정/삭제 요청 발생
2.	변경될 내용(메타데이터 또는 데이터)을 저널 영역에 먼저 기록
3.	저널 기록이 완료되면 실제 파일 시스템 영역에 변경 사항 반영
4.	모든 작업이 정상적으로 끝나면 저널 기록을 커밋(삭제 또는 완료 표시)

### 저널링 모드
- `Journal`  
  데이터 + 메타데이터 모두 저널링 (가장 안전, 가장 느림)
- `Ordered` (기본값)  
  메타데이터만 저널링, 데이터는 순서 보장
- `Writeback`  
  메타데이터만 저널링, 순서 보장 없음 (빠르나 위험)

### 장점
- ext2와 **완벽한 호환**
- 장애 복구 속도 대폭 향상
- 기존 ext2 시스템에서 무중단 업그레이드 가능

### 한계
- 파일/디렉터리 수 증가 시 성능 저하
- 대용량 파일 처리에 비효율적

---

## 3. ext4 (Fourth Extended File System)

### 등장 배경
- 대용량 디스크, 대용량 파일 사용이 일반화
- ext3 구조의 성능 한계 극복 필요

---

### 3-1. Extents 도입 (가장 큰 변화)

#### 기존 방식 (ext2 / ext3)
- 파일을 **블록 단위 리스트**로 관리
- 큰 파일일수록 inode에 저장해야 할 블록 정보 증가
- 단편화 문제 발생

#### ext4 방식 (Extents)
- 연속된 블록 묶음을 하나의 extent로 관리
- 하나의 extent = (시작 블록, 길이)

**효과**
- 메타데이터 크기 감소
- 디스크 단편화 감소
- 대용량 파일 처리 성능 향상

---

### 3-2. 대용량 지원 강화

| 항목 | ext3 | ext4 |
|---|---|---|
| 최대 파일 크기 | 2TB | 16TB |
| 최대 파일 시스템 | 16TB | 1EB |
| 디렉터리 처리 | 선형 탐색 | HTree 기반 |

---

### 3-3. 성능 및 안정성 개선

- **Delayed Allocation**
  - 실제 쓰기 시점까지 블록 할당 지연
  - 디스크 배치 최적화 → 단편화 감소

- **Multiblock Allocation**
  - 여러 블록을 한 번에 할당
  - 쓰기 성능 향상

- **Faster fsck**
  - 백그라운드 검사
  - 서버 다운타임 감소

---

## 4. ext 계열 발전 흐름 요약

| 버전 | 핵심 키워드 | 목적 |
|---|---|---|
| ext2 | 단순 구조 | 기본 성능 확보 |
| ext3 | 저널링 | 안정성·복구 |
| ext4 | Extents, 대용량 | 성능·확장성 |