# chapter10 - 프로세스와 스레드
## 10-1 프로세스 개요
### 프로세스의 종류
1. 포그라운드 프로세스
   사용자가 볼 수 있는 공간에서 실행되는 프로세스
2. 백그라운드 프로세스
   사용자가 볼 수 없는 공간에서 실행되는 프로세스
   두가지 종류가 있음
   + 사용자와 직접 상호작용이 가능한 프로세스
   + 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스 ex) 데몬, 서비스
### 운영체제는 프로세스를 어떻게 관리할까?
> 프로세스들은 돌아가며 한정된 시간 만큼만 CPU를 이용한다.
> 
> 프로세스는 타이머 인터럽트가 발생하면 차례를 양보한다.
#### 프로세스 제어 블록 (PCB)
+ 운영체제가 프로세스들을 스케줄링하기 위해 필요한, 프로세스 관련 정보를 저장하는 자료구조
+ 프로세스 생성 시, PCB는 커널 영역에 생성되고 종료 시 폐기된다.
+ 담기는 정보
  
    | 종류 | 설명 |
    | :-: | --- |
    | PID | 각 프로세스들을 식별하기 위한 고유 번호 |
    | 레지스터 값 | 실행을 재개할 때, 이전까지 사용한 레지스터 값들을 모두 복원 |
    | 프로세스 상태 | 대기, CPU 사용 중 등 현재 상태 |
    | CPU 스케줄링 정보 | 프로세스가 언제, 어떤 순서로 CPU를 할당받을 지에 대한 정보 |
    | 메모리 정보 | 프로세스가 현재 어느 주소에 저장되어 있는지에 대한 정보 (페이지 테이블 정보) |
    | 사용한 파일과 입출력 장치 정보 | 할당된 입출력 장치, 사용 중인(열린) 파일 정보 |
#### 문맥 교환 (Context Switch)
> 한 프로세스에서 다른 프로세스로 실행 순서가 넘어간다면?
> 
> 1. 기존에 실행되던 프로세스의 현재까지의 **중간 정보(=문맥)**를 **PCB**에 백업
> 2. 뒤이어 실행할 프로세스의 중간 정보를 PCB로부터 복구
### 프로세스의 메모리 영역
1. 코드 영역 (= 텍스트 영역)
   + 실행할 수 있는 코드
   + 기계어로 이루어진 명령어 저장
   + Read-only
2. 데이터 영역
   + 프로그램이 실행되는 동안 유지할 데이터를 저장하는 곳
   + ex) 전역 변수
3. 힙(heap) 영역
   + 프로그래머가 직접 할당할 수 있는 저장공간
   + C 같은 경우에는 직접 개발자가 메모리를 관리해줘야 함
   + Java 같은 경우에는 가비지 컬렉터가 사용 후 안쓰는 저장공간은 정리해줌
   + 낮은 주소에서 높은 주소로 할당됨
4. 스택(stack) 영역
   + 데이터가 일시적으로 저장되는 공간
   + ex) 매개 변수, 지역 변수
   + 높은 주소에서 낮은 주소로 할당됨
> 코드 영역, 데이터 영역은 정적할당 영역으로 크기가 변하지 않는다.
> 
> 힙 영역, 스택 영역은 동적할당 영역으로 크기가 가변적이다.
---
## 10-2 프로세스 상태와 계층 구조
### 프로세스의 상태
<img width="646" height="329" alt="Image" src="https://github.com/user-attachments/assets/d5baeb41-951e-4c6a-b4a7-85b5f9fbf459" />

1. 생성 상태
   + 이제 막 메모리에 적재되어 PCB에 할당 받은 상태
   + 준비가 완료되었다면 준비 상태로 전환됨
2. 준비 상태
   + 당장이라도 CPU를 할당받아 실행할 수 있는 상태
   + 자신의 차례가 아니기에 기다리는 상태
   + 자신의 차례가 된다면 실행상태로 전환됨 (= 디스패치)
3. 실행 상태
   + CPU를 할당 받아 실행중인 상태
   + 할당된 시간을 모두 사용 시(타이머 인터럽트 발생), **준비 상태**로 전환됨
   + 실행 도중 입출력 장치를 사용 시, 입출력 작업이 끝날때까지 **대기 상태**로 전환됨
4. 대기 상태
   + 프로세스가 실행 도중 입출력 장치를 사용하는 경우에 해당 상태가 됨
   + 왜? CPU에 비해 훨씬 입출력 작업의 속도가 느리므로, 자원 낭비를 방지하기 위해
   + 입출력 작업이 끝나면(입출력 완료 인터럽트 발생) 준비상태로 전환됨
5. 종료 상태
   + 프로세스가 종료된 상태
   + PCB, 프로세스의 메모리 영역 정리함

### 프로세스의 계층 구조
<img width="580" height="303" alt="Image" src="https://github.com/user-attachments/assets/9495d56f-072c-4aac-8386-043d35488f4c" />

> 프로세스 실행 도중 시스템 호출을 통해, 다른 프로세스 생성 가능
> 
> 부모와 자식은 별개의 프로세스이므로 각기 **다른 PID**를 가진다.
>> 일부 운영체제에서는 자식프로세스의 PCB에 부모 프로세스 PID(PPID)를 명시하기도 함
>> 최초의 프로세스 확인법 ```pstree```

### 프로세스 생성 기법
> 흔히 '복제와 옷 갈아입기' 를 통해 생성함
> 
> 다음의 내용은 윈도우 운영체제와는 상관이 없음!
#### 프로세스 생성 단계
<img width="577" height="437" alt="Image" src="https://github.com/user-attachments/assets/70371aa2-7f38-44bb-a05c-d0e5ec5629ac" />

1. 부모가 **fork** 시스템 호출 (복제)
   + 복사본(=자식 프로세스) 생성 (부모와 다른 메모리 위치에)
   + 부모 프로세스의 자원들이 상속됨
2. 자식이 **exec** 시스템 호출 (옷 갈아입기)
   + 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰기
   + 코드/데이터 영역은 새롭게 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

---
## 10-3 스레드
### 스레드란?
+ 프로세스를 구성하는 **실행 흐름의 단위**
+ 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다. ex) 화면 출력 스레드, 입력 스레드..
### 스레드 종류
1. 단일 스레드 프로세스
   + 실행 흐름이 한 개인 프로세스
2. 멀티 스레드 프로세스
   + 실행 흐름이 여러 개인 프로세스
   + 프로세스를 이루는 여러 명령어를 동시에 실행 가능하다.
### 스레드의 구성 요소
<img width="354" height="346" alt="Image" src="https://github.com/user-attachments/assets/41982cc7-31c2-4e3c-9592-a839125c96dc" />

+ 스레드 실행에 필요한 최소한의 정보를 가지고 있음
+ ex) 스레드 ID, 프로그램 카운터(PC)를 비롯한 레지스터 값, 스택 ..
> 각 스레드들은 해당 프로세스의 자원을 공유할 수 있음
### 