# Chapter9 - 운영체제 시작하기
## 09-1 운영체제를 알아야하는 이유
### 운영체제란?
+ 실행할 프로그램에 필요한 자원 할당 및 올바르게 실행되도록 돕는 **프로그램**
+ 커널 영역에 적재됨 (응용 프로그램은 사용자 영역에 적재됨)
### 운영체제의 역할
#### 1.메모리 관리
+ 응용프로그램이 사용자 영역의 어느 주소에 적재할 지 지정해줌
#### 2.CPU 관리
+ 여러개의 프로세스들을 어떤 순서로 번갈아가며 CPU 위에서 실행할 지 관리해줌
#### 3.입출력장치 관리
+ 하나의 프로세스가 입출력장치를 점유할 때 다른 프로세스가 침범하지 않도록 관리
### 운영체제가 왜 필요한가?
+ 실행 결과 출력, 연산 등 하드웨어를 조작하는 코드를 개발자가 직접 작성할 필요 없음.
+ **프로그램을 위한 프로그램**이므로, 프로그램을 만드는 개발자는 운영체제를 알아야 한다!
+ 오류메세지를 통해 운영체제와 간접적으로 개발자는 대화할 수 있다.
---
## 09-2 운영체제의 큰 그림
### 커널이란?
+ 운영체제의 핵심 서비스를 담당하는 부분
> 운영체제는 현존하는 프로그램 중 가장 용량이 큼
> 
> 유저 인터페이스는 운영체제에는 속하지만 커널에는 속하지 않음
### 운영체제의 핵심서비스 종류
#### 1. 프로세스 관리
> 실행 중인 프로그램을 프로세스라 함
+ 동시다발적으로 생성/실행/삭제 되는 다양한 프로세스들을 일목요연하게 관리
+ ex) 프로세스와 스레드, 프로세스 동기화, 교착상태 해결
#### 2. 자원 접근 및 할당
+ CPU 스케줄링: 어떤 프로세스를 먼저, 얼마나 오래 실행할지
+ 메모리 할당: 페이징과 스와핑을 통해 프로세스를 메모리에 적재 (메모리보다 용량이 큰 프로세스도 실행 가능!)
+ 입출력 장치: 인터럽트 서비스 루틴을 적용함으로써, 각각의 응용 프로그램이 입출력 장치에 접근할 수 있도록 함
#### 3. 파일 시스템 관리
+ 관련된 정보를 파일이라는 단위로 저장 장치에 보관
+ 파일들을 묶어 폴더(디렉터리) 단위로 저장 장치에 보관
### 시스템 콜(호출)과 이중 모드란?
#### 필요한 이유
+ 응용 프로그램들이 직접 자원에 접근하게 둔다면, 리스크가 발생하기 때문. (메모리 덮어씌우기 등..)
+ 응용프로그램이 자원에 접근하려면 운영체제에 도움을 요청해야함
#### 이중 모드
CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널모드로 구분하는 방식
1. 사용자 모드
    + 운영체제의 서비스를 제공받을 수 없는 실행 모드
    + 커널 영역의 코드를 실행할 수 없음
    + 자원 접근 불가
2. 커널 모드
    + 운영체제의 서비스를 제공받을 수 있는 실행모드
    + 자원 접근을 비롯한 모든 명령어 실행 가능
> CPU의 플래그 레지스터안에 **슈퍼바이저 플래그**의 값에 따라 어떤 모드인지 알 수 있음 (0: 사용자 / 1: 커널)
#### 시스템 호출
커널 모드로 전환하여 운영체제 서비스를 제공받기 위해 호출하는 것으로, 일종의 소프트웨어 **인터럽트**이다.
> 시스템 호출이 처리되는 방식은 하드웨어 인터럽트 처리 방식과 유사
> 1. 시스템  호출 (커널 모드로 전환됨)
> 2. 운영체제 코드 실행
> 3. 시스템 호출 복귀 (사용자 모드로 전환됨)

| 종류 | 시스템 호출 | 설명 |
| :-: | :-: | --- |
| 프로세스 관리 | fork() | 새 자식 프로세스 생성 |
| 프로세스 관리 | execve() | 프로세스 실행(메모리 공간을 새로운 프로그램의 내용으로 덮어씌움) |
| 프로세스 관리 | exit() | 프로세스 종료 |
| 프로세스 관리 | waitpid() | 자식 프로세스가 종료할 때까지 대기 |
| 파일 관리 | open() | 파일 열기 |
| 파일 관리 | close() | 파일 닫기 |
| 파일 관리 | read() | 파일 읽기 |
| 파일 관리 | write() | 파일 쓰기 |
| 파일 관리 | stat() | 파일 정보 획득 |
| 디렉터리 관리 | chdir() | 작업 디렉터리 변경 |
| 디렉터리 관리 | mkdir() | 디렉터리 생성 |
| 디렉터리 관리 | rmdir() | **비어있는** 디렉터리 삭제 |
| 파일시스템 관리 | mount() | 파일 시스템 마운트 |
| 파일시스템 관리 | unmount() | 파일 시스템 마운트 해제 |
---
## 부록: 시스템 호출 직접 관찰하기
### ls 명령어 분석하기
> 리눅스 명령어들의 위치: bin 디렉터리 하위에 존재
```sudo dtruss /bin/ls (mac os)
execve(" /bin/1s", ["/bin/ls"], 0x7ffcc5d7ee10 /* 35 vars */) - 0
brk(NULL)                       = 0x5607d7dc2000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffed9475e80) - -1 EINVAL (Invalid argument) access 8192, so preOd PROKITE, MAP ENONT NO Such US, directory directoryA517509000
= -1 ENOENT (No such file or directory)
openat (AT_FDCWD, "/etc/ld.so.cache", O_RDONLYI0_CLOEXEC) - 3
newfstatat(3, "*
, {st_mode=S_IFREGI0644, st_size=75755, ...}, AT_EMPTY_PATH) = ®
mmap(NULL, 75755, PROT_READ, MAP_PRIVATE, 3, 0) - 0x7f45174f6000
... 
다양한 시스템 콜이 호출됨을 알 수 있음
 ```