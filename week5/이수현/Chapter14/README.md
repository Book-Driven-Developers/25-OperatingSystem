# Chapter14 가상메모리(Virtual Memory)
## 14-1 연속 메모리 할당
<img width="530" height="279" alt="Image" src="https://github.com/user-attachments/assets/f807ea04-6bea-467f-963d-f91082faad3e" />

### 연속 메모리 할당 기법이란?
+ 프로세스에 연속적인 메모리 공간을 할당
### 스와핑
<img width="627" height="267" alt="Image" src="https://github.com/user-attachments/assets/bec0f31d-611b-44de-a58a-a57882794605" />

+ 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고(swap-out),
+ 그렇게 생긴 빈 공간에 새로운 프로세스 적재(swap-in)하는 방식
> 스왑 영역 확인법
> ```free -h```

### 메모리 할당 방식
> 메모리의 빈공간이 여러개라면, 어디에 프로세스를 적재해야할까?
#### 1. 최초 적합
  + 메모리의 빈공간을 순서대로 검색하다가 적재할 수 있는 공간을 먼저 발견한 공간에 프로세스 배치
  + **장점**: 검색 최소화, 빠른 할당
#### 2. 최적 적합
  + 운영체제가 빈 공간을 모두 검색한 뒤, 적재 가능한 가장 작은 공간에 할당
#### 3. 최악 적합
  + 운영체제가 빈 공간을 모두 검색한 뒤, 적재 가능한 가장 큰 공간에 할당
> 프로세스를 연속적으로 메모리에 할당하는 방식은 메모리를 효율적으로 사용하는 방법이 아님!
>
> **외부단편화** 문제가 발생하기 때문!!
>
> 또한 물리메모리보다 큰 프로세스를 실행 불가한다.

### 외부 단편화
+ 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
+ 예시 상황
  <p>
    <img width="526" height="290" alt="Image" src="https://github.com/user-attachments/assets/b41fe8a3-b39a-42c2-b786-10b0dd2e9bc8" />
    <em>프로세스D가 적재됐을 때, 남는 부분에 대해 외부 단편화 발생</em>
  </p>
  <p>
    <img width="433" height="365" alt="Image" src="https://github.com/user-attachments/assets/d3ee43e8-fc67-44d4-ad8d-1d5db8167419" />
    <em>최초 적합시, 남은 부분이 발생 -> 외부 단편화</em>
  </p>

#### 외부단편화 해결방법
1. 메모리 압축(compaction)
   + 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
   + 프로세스를 적당히 재배치시켜 흩어져 있는 빈 공간들을 하나의 큰 빈공간으로 만듦
   + ex. 윈도우의 디스크 조각모음
   > 단점: 재배치 과정에서 많은 오버헤드 발생!
2. 가상 메모리 기법: 페이징
   + 2장에서 설명할 예정!
---
## 14-2 페이징을 통한 가상 메모리 관리
### 가상메모리란?
+ 물리 메모리보다 훨씬 큰 프로세스를 실행할 수 있게 하는 기법
+ how? 실행하고자 하는 프로그램을 일부만 메모리에 적재
+ 방식: 페이징, 세그먼트

### 페이징이란?
<img width="613" height="271" alt="Image" src="https://github.com/user-attachments/assets/3538b32d-a5c0-4e81-b7c9-14e5c6a479fc" />

+ 프로세스의 논리주소공간을 **페이지**라는 일정 단위로 자르고
+ 메모리의 물리주소 공간을 **프레임**이라는 페이지와 동일하게 일정한 단위로 자른 뒤
+ 페이지를 프레임에 할당하는 **가상 메모리 관리 기법**

#### 페이징에서의 스와핑
  + 페이지 단위의 스왑 인, 스왑 아웃
  + 스왑 아웃: 페이지가 메모리 -> 보조기억장치
  + 스왑 인: 페이지가 보조기억장치 -> 메모리
  > 특정 프로세스의 모든 페이지가 반드시 메모리 내에 적재될 필요없다는 말!

### 페이지 테이블
#### 필요한 이유
  + 특정 프로세스들의 페이지가 메모리에 연속적이 아닌 흩어져 있다면,
  + 해당 프로세스를 실행할 때, 다음에 실행할 명령 위치를 찾기가 어려워짐!
#### 페이지 테이블이란?
  <img width="400" height="259" alt="Image" src="https://github.com/user-attachments/assets/8fb1d58c-1988-4d8a-9bdb-e3312e54e1f9" />

  + 페이지 번호와 프레임 번호를 짝지어주는 일종의 이정표
  + 프로세스마다 페이지 테이블(PTBR이 가리킴) 이 있다!
  + 테이블 내 column
    + 페이지 번호
    + 프레임 번호
    + 유효 비트
    + 보호 비트: 페이지 보호 기능을 위해 존재 (읽기 전용, 쓰기 전용 등)
    + 참조 비트: CPU가 이 페이지에 접근한 적이 있는지 여부
    + 수정 비트: CPU가 이 페이지에 데이터를 쓴(수정) 적이 있는지 여부
#### 내부 단편화 문제 발생!
  + 프로세스를 페이지 단위로 나눌 때, 마지막 페이지 부분에 남는 공간이 발생할 수 있음
  + 해당 남는 공간에 대해 내부 단편화라고 함
  > 페이지 크기 확인하는 법
  > ```getconf PAGESIZE```

#### 프로세스 테이블 베이스 레지스터 (PTBR)
  <img width="458" height="201" alt="Image" src="https://github.com/user-attachments/assets/ff6f2bca-c37e-498a-b2bb-5496f2faec8e" />
  
  + 각 프로세스의 펭지 테이블이 적재된 주소를 가리킴
  + 페이지 테이블이 메모리에 있을 때 단점
    + 메모리 접근 시간이 두배로 됨.
    + 페이지 테이블 참조 + 페이지 참조

#### TLB
  <img width="537" height="200" alt="Image" src="https://github.com/user-attachments/assets/e96982c6-6097-4d2d-bccb-c0729bc1b4d5" />

  + PTBR을 해결하기 위한 방법
  + CPU 곁에 페이지 테이블의 캐시 메모리
  + 페이지 테이블의 일부를 가져와 저장

### 페이징에서의 주소변환
+ 페이징 시스템에서의 논리 주소
  + 페이지 번호 + 변위(offset)
+ 페이지 내의 특정 주소에 접근하기 위함
+ <페이지 번호, 변위> -> 페이지 테이블 -> <프레임 번호, 변위>

### 페이지 폴트
+ 유효비트가 0인 페이지에 접근하려할 때 발생하는 **인터럽트**
+ 과정
  + CPU는 기존 작업 내역을 백업
  + 페이지 폴트 처리 루틴을 실행
  + 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤, 유효비트를 1로 변경
  + 페이지 폴트를 처리했다면, 이제 CPU는 해당 페이지에 접근할 수 있게됨

## 14-(추가) 쓰기시 복사와 계층적 페이징
### 기존의 fork 방식
<img width="448" height="215" alt="Image" src="https://github.com/user-attachments/assets/deb0fb2a-8a86-4cb2-a348-b48dcd7c5641" />

+ 프로세스는 기본적으로 자원을 공유하지 않음
+ 그래서 기존에 부모 프로세스가 적재된 별도의 메모리 공간에 자식 프로세스가 통째로 복사되어 적재됨
+ 단점: 프로세스 생성 시간 지연, 메모리 낭비
### 쓰기시 복사
<img width="506" height="234" alt="Image" src="https://github.com/user-attachments/assets/562dc6e5-4785-4d65-ae04-5f8617a27947" />

+ 부모 프로세스와 자식 프로세스 모두 초반에 같은 페이지 테이블을 가짐 (즉, 동일한 물리 주소를 가리킴)
+ 둘 중 하나가 페이지에 쓰기 작업 수행 시, 해당 페이지만 별도의 공간으로 복제
+ 장점: 프로세스 생성시간 절약, 메모리 절약 (프로세스 단위가 아닌 페이지만 복제하므로)

### 계층적 페이징
<img width="534" height="222" alt="Image" src="https://github.com/user-attachments/assets/0f415c24-c8c4-4758-a2c0-91ac5d688f68" />

+ 페이지 테이블 자체를 페이징해서, 여러 단계의 페이지를 두는 방식
+ 모든 페이지 테이블을 항상 메모리에 둘 필요가 없어짐
+ Why 필요? 
  + 프로세스의 테이블의 크기는 생각보다 작지 않음
  + 즉, 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 낭비!

+ 단점: 페이지 폴트 발생 시, 메모리 참조가 여러번 일어남
#### 논리주소
| 바깥페이지 번호 | 안쪽페이지 번호 | 변위 |

---
## 14-3 페이지 교체와 프레임 할당
### 요구 페이징
+ 처음부터 모든 페이지를 적재하지 않고, 필요한 페이지만을 메모리에 적재하는 기법
+ 요구되는 페이지만 메모리에 적재함
> 요구 페이징 시스템이 안정적으로 작동하기 위해 해결해야할 문제?
>> !페이지 교체와 프레임 할당!
---
### 페이지 교체 알고리즘
> 목적: 기존에 적재된 불팰요한 페이지를 선별해 보조기억장치로 내보내고자 
> 
> (물리 메모리의 크기는 한정되어 있으므로)
+ 당장 실행에 필요한 페이지를 적재하고자 할 때, 메모리 공간이 꽉 차있다면
+ 적재된 페이지를 보조기억장치로 내보내야함
+ 이때 어떤 페이지를 내보내야 할지 선택하는 방법이 페이지 교체 알고리즘!
> 페이지 폴트가 적은 알고리즘이 가장 좋은 알고리즘!
#### 1. FIFO
<img width="639" height="239" alt="Image" src="https://github.com/user-attachments/assets/0d90d6ac-e431-446b-b37b-a11cdd69dea8" />

+ 가장 오래 머물렀던 페이지를 내쫓는 알고리즘
+ 단점: 실행 내내 사용될 페이지가 있었다면, 계속 페이지 폴트가 일어날 것임
+ 보완책: 2차 기회(second-chance) 페이지 교체 알고리즘
  + 참조 비트 1: 한번 더 기회를 주기(참조 비트를 0으로 초기화 후, 적재 시간을 현재로 설정)
  + 참조 비트 0: 내쫓기
#### 2. 최적 페이지 교체 알고리즘
<img width="570" height="236" alt="Image" src="https://github.com/user-attachments/assets/ff0bca87-a4af-433a-bb46-4088a1e9366e" />

+ CPU에 의해 참조되는 횟수를 고려한 알고리즘
+ 앞으로도 자주 사용되지 않**을** 페이지를 예측해야함
+ 장점: **가장 낮은** 페이지 **폴트율**을 보장
+ 단점: 실제 구현이 어려움 -> 앞으로 오랫동안 사용되지 않을 페이지를 어떻게 예측?
> 주로 성능 평가의 척도로 사용됨
#### 3. LRU
<img width="514" height="213" alt="Image" src="https://github.com/user-attachments/assets/e0f11494-e176-492f-8bca-0239b5be0189" />

+ 가장 오래 사용되지 않**은** 페이지를 교체
---
### 프레임 할당
> 프로세스가 사용할 수 있는 충분한 프레임을 제공함으로써, 페이지 폴트 빈도를 낮추고자함
#### 들어가기전: 스레싱
<p>
<img width="450" height="221" alt="Image" src="https://github.com/user-attachments/assets/2206240a-6ac7-4402-ad29-7d919a1a76e6" />
<em>동시에 실행되는 프로세스의 수를 늘린다고 CPU이용률이 높아지는 것이 아님!</em>
</p>

  + 프로세스가 실행되는 시간 < 페이징 시간
  + CPU 성능을 저하하는 문제
  + 발생 원인
    + 각 프로세스가 필요로하는 최소한의 프레임 수가 보장되지 않아서
#### 1. 균등 할당
  + 가장 단순한 정적 할당 방식
  + 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
  + 단점: 프로세스들의 크기가 모드 다르다는 점에서 공정성이 없음
#### 2. 비례 할당
  + 프로세스의 크기를 고려하는 정적 할당 방식
  + 프로세스의 크기에 비례하여 프레임 할당
#### 3. 동적 할당
  + 프로세스가 필요로 하는 프레임 수는 **실행해봐야 안다**는 지점에서 출발
  + 3.1: 작업 집합 모델
    + CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 페이지를 할당
  + 3.2: 페이지 폴트 빈도 기반 모델
    <img width="577" height="217" alt="Image" src="https://github.com/user-attachments/assets/58479de9-f52b-40fd-9148-a4e68934ed3f" />

    + 페이지 폴트울에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식