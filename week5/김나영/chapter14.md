# 14-1 연속 메모리 할당
프로세스에 연속적인 메모리 공간을 할당하는 방식
## 스와핑
메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

스왑 영역 : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역

스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것

스왑 인 : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

![alt text](img1.png)

### 스왑 영역 확인하기
```
free -h
```
유닉스와 리눅스, macOS에서 free, top 명령어 등을 통해 스왑 영역의 크기를 확인할 수 있음

## 메모리 할당
비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식

### 최초 적합 first fit
운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식

장점 : 검색 최소화, 빠른 할당이 가능

### 최적 적합 best fit
빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 **가장 작은 공간**에 프로세스 배치

### 최악 적합 worst fit
빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 **가장 큰 공간**에 프로세스 배치

## 외부 단편화
프로세스들이 메모리에 연속적으로 할당하는 환경에서는 프로세스들이 실행되고 종료되며 메모리 사이 사이에 빈 공간이 발생

이 빈 공간들에 더 큰 프로세스를 어려운 상황을 초래하고, 결국 메모리 낭비로 이어짐

![alt text](img2.png)

### 해결 방법 : 압축
여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식

메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩여져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방식

![alt text](img3.png)

단점
- 작은 빈 공간들을 하나로 모으는 동안 시스템 중지
- 많은 오버헤드 야기
- 오버헤드 최소화에 대한 명확한 방법 결정 어려움

# 14-2 페이징을 통한 가상 메모리 관리
가상 메모리 (virtual memory) : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

## 페이징
프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임**이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 **가상 메모리 관리 기법**

페이징에서 스와핑 사용 방법
- 페이지 단위로 스왑 아웃/스왑 인
- 페이지 아웃 : 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
- 페이지 인 : 실행에 필요한 페이지들은 메모리로 스왑 인

![alt text](img4.png)

## 페이지 테이블
프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 순차적으로 실행할 수 없음

프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블** 이용

어떤 페이지가 어떤 프레임에 할당되었는지 알려줌

![alt text](img5.png)

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있음

### PTBR

CPU 내의 **페이지 테이블 베이스 레지스터 : PTBR** 는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있음

![alt text](img7.png)

하지만 메모리에 있는 페이지 테이블을 보기 위해 한번, 그렇게 알게 된 프레임에 접근하기 위해 한번, 총 두번의 메모리 접근이 생긴다.

### TLB
이를 해결하기 위해 TLB : Translation Lookaside Buffer 라는 페이지 테이블의 **캐시 메모리**를 둠

참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 저장

![alt text](img8.png)

TLB 히트 : CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우

TLB 미스 : 만일 페이지 번호가 TLB에 없을 경우, 메모리 내의 페이지 테이블에 접근

## 내부 단편화
페이징은 프로세스의 논리 주소 공간을 페이지 단위로 자르지만, 모든 프로세스가 페이지 크기에 딱 맞게 잘리지 않는다.

마지막 페이지는 메모리 낭비 발생 => 내부 단편화

![alt text](img6.png)

페이지 크기가 작다면 발생하는 내부 단편화의 크기는 작아질 수 있지만, 그만큼 페이지 테이블의 크기가 커져 페이지 테이블이 차지하는 공간이 낭비됨

내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요함

## 페이징에서의 주소 변환

