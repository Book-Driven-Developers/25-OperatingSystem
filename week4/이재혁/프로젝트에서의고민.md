- 실제 내 프로젝트에서는 자바 동기화 코드를 사용하고 있지 않기 때문에 데드락 가능성은 애플리케이션에서는 가능성이 낮다
- DB 단에서 데드락이 걸린다면 아래와 같은 상황을 생각해볼 수 있다.


- 아래 2개 작업이 동일 시점에 실행
    - A → B 에게 100원 송금
    - B → A 에게 500원 송금
- 트랜잭션의 처리 순서

```sql
Tx-1> UPDATE wallet SET amount=amount-100 WHERE user_id='A';
Tx-2> UPDATE wallet SET amount=amount-500 WHERE user_id='B';
Tx-1> UPDATE wallet SET amount=amount+100 WHERE user_id='B';
Tx-2> UPDATE wallet SET amount=amount+500 WHERE user_id='A';
```

⇒ 데드락 발생

- 생각의 순서대로 프로그램 작성
    - DBMS는 다음에 실행될 SQL을 예측하지 못함
    - 이런 형태에서 Dead Lock 발생 가능성 높음
- 정렬된 순서대로 처리
    - “-” 처리 먼저 “+” 처리는 나중에 수행하던 방식 ⇒ user_id 순서대로 처리
    - Index(user_id) 순서대로 잠금 실행 시,
      Lock wait은 발생할 수 있지만, DeadLock은 없음

⇒ 트랜잭션 처리를 직렬처리하여 데드락 해결






- DeadLock은 회피할 수 있는 경우도 있지만, 회피할 수 없는 경우가 더 많음
- DeadLock이 발생했다고 해서, UniqueKey나 PK를 삭제할 수는 없음(가능하다면, 모델링 시점에서 최소화)
    - 유니크 인덱스는 성능적 장점은 전혀 없지만 잠금 빈도와 데드락 가능성만 높인다.
- DeadLock의 발생 빈도와 서비스 영향도에 따라서 무시
- 프로그램 코드에서의 트랜잭션 재처리
    - if(sqlEx.getSqlState() == “40001”) { retry; }
- Retry 코드를 넣었다고 해서, 코드 품질이 낮아지는 것은 아님