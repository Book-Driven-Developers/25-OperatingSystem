# chapter11 - CPU 스케줄링
## 11-1 CPU 스케줄링 개요
### CPU 스케줄링이란?
+ 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
> 어떻게 공정하고 합리적으로 배분할 것인지가 학습의 목표!
> 
> 프로세스마다 중요도가 다르기 때문이다. ex) 입출력 집중 프로세스의 우선순위 >  CPU 집중 프로세스의 우선순위
>> 입출력 집중 프로세스는 어짜피 입출력 장치를 사용하게 되면 대기 상태에 머물러 CPU를 한동안 사용하지 않음.
>> 
>> 그러므로 한번 CPU가 필요할 때 더 우선순위를 높여 빨리 CPU 작업을 하도록 하는 것이 좋음
### 프로세스 우선순위
<img width="497" height="208" alt="Image" src="https://github.com/user-attachments/assets/f3578368-80e8-488f-bd81-fee345c40059" />

+ **PCB**에 우선순위가 저장됨
### 스케줄링 큐
<img width="289" height="247" alt="Image" src="https://github.com/user-attachments/assets/32f7aa68-7cf3-475f-a6a7-6d40e615c62d" />

+ 각 스케줄링 큐에 특정 자원을 이용하고 싶어하는 프로세스들을 넣음
  > 운영체제가 일일이 모든 PCB를 관찰할 수 없으므로
+ **먼저 큐에 들어왔다고 해서 먼저 나간다는 보장은 없음!**
#### 스케줄링 큐의 종류
<img width="289" height="240" alt="Image" src="https://github.com/user-attachments/assets/a45e9767-1cf1-44b3-9c17-162fcc2af32d" />

1. 준비 큐: 준비 상태에 있는 프로세스들이 있는 큐
2. 대기 큐: 대기 상태에 접어든 프로세스들이 있는 큐 ex) 프린터 대기 큐, CD-ROM 대기 큐, 하드디스크 대기 큐...
    > 대기큐에서 입출력 완료 인터럽트를 받으면 해당 프로세스는 준비 상태로 전환되어 준비큐로 이동한다.
### 선접형과 비선점형 스케줄링
#### 1. 선점형 스케줄링 (preemptive scheduling)
+ 현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
+ **장점**: 어느 한 프로세스의 자원 독점을 막으며, 프로세스들에 골고루 자원을 배분할 수 있음
+ **단점**: 그만큼 문맥 교환 과정에 대한 오버헤드가 발생할 수 있음
#### 2. 비선점형 스케줄링 (non-preemptive scheduling)
+ 현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스를 기다림
+ **장점**: 상대적으로 문맥 교환에서 발생하는 오버헤드가 적음
+ **단점**: 모든 프로세스가 골고루 자원을 이용하기 어려움
---
## 11-2 CPU 스케줄링 알고리즘
> 각 알고리즘의 작동방식, 장단점에 주목!!
> 
> 본 교재에서는 알고리즘들 중 7가지만 추려서 보여준다.
### 1. 선입 선처리 스케줄링 (First Come First Served)
<img width="400" height="208" alt="Image" src="https://github.com/user-attachments/assets/65080429-fbd8-416c-8055-f8cb437d301d" />

+ 단순히 준비 큐에 삽입된 순서대로 처리하는 **비선점형** 스케줄링
+ 즉, 먼저 CPU를 요청한 프로세스부터 CPU 할당
#### 단점
  + 프로세스들이 기다리는 시간이 매우 길어질 수 있음 => **호위 효과**
  > 호위효과를 방지하려면? => SJF 스케줄링


### 2. 최단 작업 우선 스케줄링 (Shortest Job First)
<img width="431" height="224" alt="Image" src="https://github.com/user-attachments/assets/55ba27b9-2adb-43bc-9996-afcc48158379" />

+ CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 **비선점형** 스케줄링
+ CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
+ 비선점으로 구분되지만, 선점으로도 구현될 수 있음.


### 3. **라운드 로빈 스케줄링** (Round Robin)
<img width="456" height="251" alt="Image" src="https://github.com/user-attachments/assets/b04c4d6f-8430-41e4-9b31-eeb167ea67fc" />

+ 정해진 타임 슬라이스만큼의 시간동안 돌아가며 CPU를 이용하는 **선점형** 스케줄링
+ 선입 선처리 스케줄링 + 타임 슬라이스
  > 타임슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
  >
  > 타임 슬라이스의 크기에 따라, 스케줄링의 효율성이 결정됨.
+ 정해진 시간을 모두 사용하였는데도 아직 프로세스가 완료되지 않으면, 다시 큐의 맨 뒤에 삽입됨 => 문맥 교환!


### 4. 최소 잔여 시간 우선 스케줄링 (Shortest Remaining Time)
+ 정해진 시간만큼 CPU를 이용하되,
  다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스를 선택하는 
  **선점형** 스케줄링
+ SJF + RR 이라고 볼 수 있음


### 5. 우선순위 스케줄링 (Priority)
<img width="366" height="215" alt="Image" src="https://github.com/user-attachments/assets/a5c1d5c4-cb8b-4c47-94ba-978c843335c6" />

+ 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행하는 스케줄링
  > SJF, SRT 스케줄링 모두 여기에 포함되는 개념이라 볼 수 있음
+ if 우선순위가 같다면, 선입 선처리로 스케줄링함
+ 비선점형, 선점형 둘다 가능하다
  > 비선점형: CPU를 잡으면 끝날때까지 실행
  > 선점형: 더 높은 우선순위 프로세스가 오면 즉시 교체
#### 단점
  + **기아현상**: 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입되어도 **실행이 계속해서 연기**될 수 있음
  > 방지 기법: **에이징**
    >> 오랫동안 대기한 프로세스의 우선 순위를 점차 높이는 방식


### 6. 다단계 큐 스케줄링 (Multilevel Queue)
<img width="371" height="194" alt="Image" src="https://github.com/user-attachments/assets/ff51e33c-f2d1-4673-b8bc-fc0a30833259" />

+ 우선순위 스케줄링의 발전된 형태로,
  우선순위별로 준비 큐를 여러 개 사용하는 **선점형** 스케줄링 방식
+ 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 해당 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스를 처리함
#### 장점
  + 큐 별로 스케줄링 알고리즘을 달리 적용해서 프로세스를 유형별로 처리하기 쉬워짐!
#### 단점
  + 큐 간에 프로세스가 이동할 수 없음
  + 즉, 우선순위가 낮은 큐에 있는 프로세스는 계속해서 그곳에 머물러 실행이 연기됨 => 기아현상 발생 가능!


### 7. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue)
<img width="433" height="222" alt="Image" src="https://github.com/user-attachments/assets/0509235b-846b-471d-8219-9b932e11173a" />

+ 다단계 큐 스케줄링의 발전된 형태의 **선점형** 스케줄링 (일반적인 CPU 스케줄링으로 사용함)
+ 큐 간의 이동이 가능함
#### 작동 방식
  1. 먼저 우선순위가 가장 높은 큐에 새롭게 준비상태가 된 프로세스가 삽입됨
  2. 타임슬라이스만큼 해당 프로세스가 CPU를 사용함.
  3. 만약 타임슬라이스 후 실행이 아직 안 끝났다면, 그 다음 낮은 우선순위의 큐로 삽입됨
  4. 프로세스가 종료될 때까지 2,3번이 반복됨
  > 즉, *CPU를 많이 이용해야하는 프로세스*일수록, 점차 우선순위가 낮아짐

#### 에이징 기법 적용
+ 낮은 우선순위큐에서 계속 머물러있던 프로세스의 우선순위를 다음 우선순위 큐로 높일 수 있음
---
## 11-3 스케줄링 구현 (JAVA)
### 1. 소스코드 실행 방법
```bash
./gradlew bootRun --args="<process_file> <algorithm>"
# 예)
./gradlew bootRun --args="processes.txt fcfs"
```

### 2. 입력값
#### 2.1 초기 프로세스 파일 입력 포맷
+ 한 줄당 하나의 프로세스(PCB)를 가리킴
+ #으로 시작하는 줄은 주석으로 자동 무시
+ 빈 줄도 무시
```text
# pid, arrival, burst
1,0,5
2,2,3
3,4,2
```

#### 2.2 실행 중 콘솔 입력 포맷
+ 프로그램 실행 중 콘솔에서 새로운 프로세스를 추가할 수 있습니다.
+ 콘솔로 입력한 프로세스는 현재 clock으로 자동 설정됩니다.
+ quit 입력 시, 콘솔 입력이 종료됩니다. (시뮬레이터는 모든 프로세스가 종료될때까지 실행됨)
+ pid, burstTime을 입력합니다.
```bash
새로운 프로세스 정보를 입력해주세요(종료 시 quit): 
10,5
11,2
quit
```
### 3. 출력값
+ 시뮬레이션이 종료되면, 각 프로세스의 실행결과와 평균 지표를 출력합니다.
#### 3.1 출력 컬럼 설명

| 컬럼 | 의미 |
| *-* | --- |
| PID | 프로세스 ID |
| ARR | 프로세스가 준비큐에 도착한 시간 |
| BURST | 실행시간 |
| START | 처음 CPU를 점유한 시간 |
| FINISH | 종료 시간 |
| WAIT | 대기 시간 |
| TAT | 총 걸린 시간 |
| RESP | 도착 후 실행까지 걸린 시간 |

#### 3.2 출력 예시
```bash
===== Report =====
PID | ARR | BURST | START | FINISH | WAIT | TAT | RESP
  1 |   0 |     5 |     0 |      5 |    0 |   5 |    0
  2 |   2 |     3 |     5 |      8 |    3 |   6 |    3
AVG WAIT=1.50, AVG TAT=5.50, AVG RESP=1.50
==================
```

### 4. 종료 조건
아래 조건을 모두 만족하면 시뮬레이션을 종료하고 Report를 출력합니다.
+ futureArrivals(도착 예정 프로세스)가 비어있음
+ readyQueue가 비어있음
+ 현재 실행 중인 프로세스(current)가 없음
